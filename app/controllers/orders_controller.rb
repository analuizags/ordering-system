class OrdersController < ApplicationController
  before_action :set_order, only: [:show, :edit, :update, :cancel, :to_do, :done, :close]
  before_action :set_products, only: [:new, :edit, :update, :create]
  before_action :set_tables, only: [:new, :edit, :update, :create]
  before_action :set_categories, only: [:new, :edit, :update, :create]

  def index
    @orders = Order.order(:created_at)
  end

  def show
  end

  def new
    @order = Order.new

    set_products.each do |product|
      order_product = OrderProduct.new
      order_product.product = product
      @order.order_products << order_product
    end

    @order
  end

  def edit
    # out_order_products = set_products.select {|product| !@order.products.include?(product)}

    # out_order_products.each do |product|
    #   order_product = OrderProduct.new
    #   order_product.product = product
    #   @order.order_products << order_product
    # end

    # @order
  end

  def create
    @order = Order.new(order_params)

    @order.status = "registrado"
    @order.work_shift_id = current_work_shift.id

    respond_to do |format|
      if @order.save
        format.html { redirect_to @order, notice: 'Order was successfully created.' }
        format.json { render :show, status: :created, location: @order }
      else
        format.html { render :new }
        format.json { render json: @order.errors, status: :unprocessable_entity }
      end
    end
  end

  def update
    params[:order].delete(:status)
    params[:order].delete(:work_shift_id)

    respond_to do |format|
      if @order.update(order_params)
        format.html { redirect_to @order, notice: 'Order was successfully updated.' }
        format.json { render :show, status: :ok, location: @order }
      else
        format.html { render :edit }
        format.json { render json: @order.errors, status: :unprocessable_entity }
      end
    end
  end

  def destroy
    # @order.destroy
    respond_to do |format|
      format.html { redirect_to orders_url, notice: 'Order was successfully destroyed.' }
      format.json { head :no_content }
    end
  end

  def to_do
    @order.to_do!
    respond_to do |format|
      format.html { redirect_to orders_path, notice: 'Order was successfully updated status.' }
      format.json { render :show, status: :ok, location: @order }
    end
  end

  def done
    @order.done!
    respond_to do |format|
      format.html { redirect_to orders_path, notice: 'Order was successfully updated status.' }
      format.json { render :show, status: :ok, location: @order }
    end
  end

  def close
    @order.close!
    respond_to do |format|
      format.html { redirect_to orders_path, notice: 'Order was successfully closed.' }
      format.json { render :show, status: :ok, location: @order }
    end
  end

  def cancel
    @order.cancel!
    respond_to do |format|
      format.html { redirect_to orders_path, notice: 'Order was successfully canceled.' }
      format.json { render :show, status: :ok, location: @order }
    end
  end

  private
    def set_products
      @products = Product.joins(:category).where(categories: {active: true}).order("categories.name")
    end

    def set_categories
      @categories = Product.joins(:category).select("categories.id, categories.name").where(categories: {active: true}).uniq.order("categories.name")
    end

    def set_tables
      @tables = []
      (1..40).each {|n| @tables << "Mesa #{sprintf('%02d', n)}"}
      @tables
    end

    def set_order
      @order = Order.find(params[:id])
    end

    def order_params
      params.require(:order).permit(:table, :status, :work_shift_id,
        order_products_attributes: [:id, :quantity, :note, :product_id])
    end

    def has_open_work_shift?
      current_work_shift
    end

    def current_work_shift
      WorkShift.joins(:restaurant).where(restaurants: {user_id: current_user.id}).where(end_at: nil)[0]
    end
end
